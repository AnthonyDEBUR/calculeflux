# WARNING - Generated by {fusen} from /dev/flat_full.Rmd: do not edit by hand

#' This function allows for importing available piezometric data from the Piezometrie 
#' HUB'EAU API (https://hubeau.eaufrance.fr/page/api-piezometrie).
#' 
#' @param code_bss vector with list of old bss code for piezometre (ex. 04193X0022/S2-6) 
#' @param date_debut start date of observations to retrieve (optional)
#' @param date_fin end date of observations to retrieve (optional)
#'
#' @return the function returns a tibble with the code of the piezotric station, 
#' the date, and the daily piezometric 
#' 
#' @export
#' @examples
#' importe_piezo_hubeau(code_bss="04193X0022/S2-6",
#'                      date_debut = as.Date("2010-01-01"),
#'                      date_fin=as.Date("2011-01-01"))
#' 
#'   # https://hubeau.eaufrance.fr/api/v1/niveaux_nappes/chroniques?&date_debut_mesure=2010-01-01&date_fin_mesure=2011-01-01&size=20
importe_piezo_hubeau <- function(code_bss,
                                 date_debut = NULL,
                                 date_fin = NULL) {
  #astuces pour éviter note no visible binding for global variable
  . <- NULL
  
  # profondeur de resultat max selon API hubeau
  limite_api_hubeau <- 20000
  
  if(is.null(code_bss)){
    stop("importe_piezo_hubeau : code_bss can\'t be NULL")
  }
  if(!is.null(code_bss)){
  if (!is.character(code_bss) & !is.factor(code_bss)) {
    stop("importe_piezo_hubeau : code_bss must be of class character or factor")
  }}

  if (!is.null(date_debut)) {
    if (!lubridate::is.Date(date_debut)) {
      stop("importe_piezo_hubeau : date_debut must be of class Date")
    }
  } else {
    date_debut <- as.Date("1900-01-01")
  }
  
  
  if (!is.null(date_fin)) {
    if (!lubridate::is.Date(date_fin)) {
      stop("importe_piezo_hubeau : date_fin must be of class Date")
    }
  } else {
    date_fin <- as.Date(Sys.Date())
  }
  
  url_base <-
    "https://hubeau.eaufrance.fr/api/v1/niveaux_nappes/chroniques?"
  
  ##### On determine le nb de resultat renvoye par la requete #####
  
  ss_fct_requet <- function(code_bss0,
                            date_debut0,
                            date_fin0,
                            size0)
  {
    requete <- list(
      date_debut_mesure = date_debut0,
      date_fin_mesure = date_fin0,
      size = size0
    )
    
      if (!is.null(code_bss0)) {
      requete <-
        c(requete, code_bss = list(paste0(code_bss0, collapse = ",")))
    }
 
    
    data <- httr::GET(url_base,
                      query = requete)
    
    httr::warn_for_status(data)
    httr::stop_for_status(data)
    
    return(data)
  }
  
  ss_fct_nb_rslt <- function(data00) {
    nb_result0 <- data00 %>%
      httr::content(as = 'text', encoding = "UTF-8") %>%
      jsonlite::fromJSON()
    
    return(nb_result0$count)
  }
  
  ss_fct_tab_rslt <- function(data00) {
   # print(data00$url)
    if (data00$status_code == 200)
    {
      data00 <- data00 %>%
        httr::content(as = 'text', encoding = "UTF-8") %>%
        jsonlite::fromJSON() %>%
        .$data
    } else
    {
      stop(
        paste0(
          "importe_piezo_hubeau : error in Hubeau API result, status code = ",
          data00$status_code,
          " - url = ",
          data00$url
        )
      )
    }
    return(data00)
  }
  
  
  #nb de resultat renvoyés par la requête
  data0 <- ss_fct_requet(
    code_bss0 = code_bss,
    date_debut0 = date_debut,
    date_fin0 = date_fin,
    size0 = 10
  )
  
  nb_result <- ss_fct_nb_rslt(data0)
  
  # traitement différencié si tous les résultats peuvent ou pas être exportés par Hubeau.
  # Si oui alors on les exporte, si non alors on split la requête pour pouvoir faire plusieurs exports
  if (nb_result <= limite_api_hubeau & nb_result>0)
  {
    data0 <- ss_fct_requet(
      code_bss0 = code_bss,
    date_debut0 = date_debut,
    date_fin0 = date_fin,
    size0 = limite_api_hubeau
    )
    
    
    data0 <- ss_fct_tab_rslt(data0)
    
    
    
  } else if (nb_result>0)
  {
    ##### Si trop de lignes pour exporter en une fois, on split la requête #####
    
    # on decoupe en n intervalles les périodes demandées
    nb_split <- ceiling(nb_result / limite_api_hubeau)
    
    trg_split_en_cours <- TRUE
    k <- 1
    
    while (trg_split_en_cours) {
      # nb de jours dans chaque intervalle
      nb_day_interv <- round((date_fin - date_debut) / (k * nb_split))
      
      # on decoupe les dates en nb de split
      dates_a_traiter <- unique(c(seq(date_debut, date_fin, by = nb_day_interv), date_fin))
      dates_a_traiter <-
        data.frame(dates_debut = (dates_a_traiter[1:(length(dates_a_traiter) - 1)]+1),
                   dates_fin = dates_a_traiter[2:length(dates_a_traiter)])
      dates_a_traiter[1,]$dates_debut<-dates_a_traiter[1,]$dates_debut-1
      
      #on compte le nb de resultats de chaque période
      nb_rst_per <- function(i)
      {
        data0 <- ss_fct_requet(
                 code_bss0 = code_bss,
          date_debut0 = dates_a_traiter$dates_debut[i],
          date_fin0 = dates_a_traiter$dates_fin[i],
          size0 = 10
        )
        
        return(ss_fct_nb_rslt(data0))
      }
      
      dates_a_traiter$nb <-
        sapply(seq(1, nrow(dates_a_traiter)), nb_rst_per)
      
      k <- k + 1
      if (all(dates_a_traiter$nb < limite_api_hubeau)) {
        trg_split_en_cours <- FALSE
      }
      if (k >= nb_day_interv) {
        stop(
          "importe_qualite_hubeau : unable to get all available results, try to restrict input parameters"
        )
      }
    }
    rm(k, trg_split_en_cours, nb_split)
    
    # on regroupe des lots à traiter les plus gros possibles
    l0 <- 1
    lot <- 1
    dates_a_traiter$lot <- 0
    for (k in 1:nrow(dates_a_traiter)) {
      if (sum(dates_a_traiter$nb[l0:k]) < limite_api_hubeau) {
        dates_a_traiter$lot[k] <- lot
      } else
      {
        lot <- lot + 1
        dates_a_traiter$lot[k] <- lot
        l0 <- k
      }
    }
    rm(l0, lot)
    dates_a_traiter<-dates_a_traiter[dates_a_traiter$nb!=0,]
      
    lots <- unique(dates_a_traiter$lot)

    ##### On rapatrie les données par lot de date #####
    data0 <- do.call(dplyr::bind_rows,
                     lapply(lots,
                            function(lot0) {
                              print(paste0("treating batch ", lot0, " on ", length(lots)))
                              tmp123<-ss_fct_tab_rslt(
                                ss_fct_requet(
                                  code_bss0 = code_bss,
                                  code_station0 = code_station,
                                  date_debut0 = min(dates_a_traiter[dates_a_traiter$lot ==
                                                                      lot0, ]$dates_debut),
                                  date_fin0 = max(dates_a_traiter[dates_a_traiter$lot ==
                                                                    lot0, ]$dates_fin),
                                  size0 = limite_api_hubeau,
                                  code_parametre0 = code_parametre,
                                  code_support0 = code_support,
                                  code_fraction0 = code_fraction
                                )
                              )
                              Sys.sleep(0.3)
                              return(tmp123)
                            }))
    
  } else {data0<-data.frame()}
  
  if(nrow(data0)!=nb_result) {warning(paste0("importe_piezo_hubeau : the fuction return ",
                                             nrow(data0), " lines whereas hubeau API should return ", nb_result))}
  
  return(data0)

  
}
